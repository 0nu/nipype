import os

from nipype.testing import *
import nipype.interfaces.fsl as fsl


def test_fslversion():
    ver = fsl.fslversion().split('.')
    yield assert_equal, ver[0], '4'

    
def test_fsloutputtype():
    types = ['ANALYZE_GZ', 'NIFTI_PAIR_GZ', 'NIFTI', 'NIFTI_PAIR',
             'NIFTI_GZ', 'ANALYZE']
    out_type, ext = fsl.fsloutputtype()
    yield assert_true, out_type in types
    env_type = os.environ.get('FSLOUTPUTTYPE')
    if env_type:
        # Set to same value for test.
        out_type, ext = fsl.fsloutputtype(env_type)
        yield assert_equal, out_type, env_type


def test_FSLCommand():
    # Most methods in FSLCommand are tested in the subclasses.  Only
    # testing the one item that is not.
    cmd = fsl.FSLCommand()
    cmd.cmd = 'bet' # Set the cmd to something
    res = cmd.run()
    yield assert_equal, type(res), fsl.InterfaceResult
    

# test Bet
def test_bet():
    better = fsl.Bet()
    yield assert_equal, better.cmd, 'bet'

    # Test raising error with mandatory args absent
    yield assert_raises, AttributeError, better.run

    # .inputs based parameter setting
    better.inputs.frac = 0.5
    better.inputs.infile = 'infile'
    better.inputs.outfile = 'outfile'
    yield assert_equal, better.cmdline, 'bet infile outfile -f 0.50'

    # .run() based parameter setting
    betted = better.run(infile='infile2', outfile='outfile')
    # Non-existant files, shouldn't finish cleanly
    yield assert_not_equal, betted.runtime.returncode, 0
    yield assert_equal, betted.interface.inputs.infile, 'infile2'
    yield assert_equal, betted.interface.inputs.outfile, 'outfile'
    yield assert_equal, betted.runtime.cmdline, 'bet infile2 outfile -f 0.50'
    
    # test that an outfile is autogenerated when inputs.outfile is None
    better.inputs.infile = 'infile'
    better.inputs.outfile = None
    allargs = better._parse_inputs()
    yield assert_equal, allargs[1], os.path.join(os.path.abspath('.'),'infile_bet')

    # Our options and some test values for them
    # Should parallel the opt_map structure in the class for clarity
    opt_map = {
        'outline':            ('-o', True),
        'mask':               ('-m', True),
        'skull':              ('-s', True),
        'nooutput':           ('-n', True),
        'frac':               ('-f 0.40', 0.4),
        'vertical_gradient':  ('-g 0.75', 0.75),
        'radius':             ('-r 20', 20),
        'center':             ('-c 54 75 80', (54, 75, 80)),
        'threshold':          ('-t', True),
        'mesh':               ('-e', True),
        'verbose':            ('-v', True),
        'flags':              ('--i-made-this-up', '--i-made-this-up'),
            }
    # Currently we don't test -R, -S, -B, -Z, -F, -A or -A2
    

    # test each of our arguments
    for name, settings in opt_map.items():
        better = fsl.Bet(**{name: settings[1]})
        yield assert_equal, better.cmdline, ' '.join([better.cmd, settings[0]])
    
        
# test fast
def test_fast():
    faster = fsl.Fast()
    faster.inputs.verbose = True
    fasted = faster.run(infiles='infile')
    fasted2 = faster.run(infiles=['infile', 'otherfile'])
    
    yield assert_equal, faster.cmd, 'fast'
    yield assert_equal, faster.inputs.verbose, True
    yield assert_equal, faster.inputs.manualseg , None
    yield assert_not_equal, faster, fasted
    yield assert_equal, fasted.runtime.cmdline, 'fast --verbose infile'
    yield assert_equal, fasted2.runtime.cmdline, 'fast --verbose infile otherfile'

    faster = fsl.Fast()
    faster.inputs.infiles = 'foo.nii'
    yield assert_equal, faster.cmdline, 'fast foo.nii'
    faster.inputs.infiles = ['foo.nii', 'bar.nii']
    yield assert_equal, faster.cmdline, 'fast foo.nii bar.nii'
    
    # Our options and some test values for them
    # Should parallel the opt_map structure in the class for clarity
    opt_map = {'number_classes':       ('--class 4', 4),
               'bias_iters':           ('--iter 5', 5),
               'bias_lowpass':         ('--lowpass 15', 15),
               'img_type':             ('--type 2', 2),
               'init_seg_smooth':      ('--fHard 0.035', 0.035),
               'segments':             ('--segments', True),
               'init_transform':       ('-a xform.mat', 'xform.mat'),
               'other_priors':         ('-A prior1.nii prior2.nii prior3.nii', 
                       ('prior1.nii', 'prior2.nii', 'prior3.nii')),
               'nopve':                ('--nopve', True),
               'output_biasfield':     ('-b', True),
               'output_biascorrected': ('-B', True),
               'nobias':               ('--nobias', True),
               'n_inputimages':        ('--channels 2', 2),
               'out_basename':         ('--out fasted', 'fasted'),
               'use_priors':           ('--Prior', True),
               'segment_iters':        ('--init 14', 14),
               'mixel_smooth':         ('--mixel 0.25', 0.25),
               'iters_afterbias':      ('--fixed 3', 3),
               'hyper':                ('--Hyper 0.15', 0.15),
               'verbose':              ('--verbose', True), 
               'manualseg':            ('--manualseg intensities.nii',
                       'intensities.nii'),
               'probability_maps':     ('-p', True),
              }
   
    # test each of our arguments
    for name, settings in opt_map.items():
        faster = fsl.Fast(**{name: settings[1]})
        yield assert_equal, faster.cmdline, ' '.join([faster.cmd, settings[0]])


#test flirt
def test_flirt():
    flirter = fsl.Flirt()
    flirter.inputs.bins = 256
    flirter.inputs.cost = 'mutualinfo'
    flirted = flirter.run(infile='infile',reference='reffile',
                          outfile='outfile',outmatrix='outmat.mat')
    flirt_est = flirter.run(infile='infile',reference='reffile',
                            outfile=None,outmatrix='outmat.mat')
    flirt_apply = flirter.applyxfm(infile='infile',reference='reffile',
                                   inmatrix='inmatrix.mat',outfile='outimgfile')
    
    yield assert_not_equal, flirter, flirted
    yield assert_not_equal, flirted, flirt_est
    yield assert_not_equal, flirted, flirt_apply

    yield assert_equal, flirter.cmd, 'flirt'
    yield assert_equal, flirter.inputs.bins, flirted.interface.inputs.bins
    yield assert_equal, flirter.inputs.cost, flirt_est.interface.inputs.cost
    yield assert_equal, flirter.inputs.cost, flirt_apply.interface.inputs.cost
    yield assert_equal, flirt_apply.runtime.cmdline,'flirt -in infile -ref reffile -omat outmat.mat -init inmatrix.mat -out outimgfile -cost mutualinfo -applyxfm -bins 256'
    
    flirter = fsl.Flirt()
    # infile not specified
    yield assert_raises, AttributeError, flirter.applyxfm
    flirter.inputs.infile = 'foo.nii'
    # reference not specified
    yield assert_raises, AttributeError, flirter.applyxfm
    flirter.inputs.reference = 'mni152.nii'
    # inmatrix not specified
    yield assert_raises, AttributeError, flirter.applyxfm
    flirter.inputs.inmatrix = 'inmatrix.mat'
    res = flirter.applyxfm()
    realcmd = 'flirt -in foo.nii -ref mni152.nii -init inmatrix.mat -applyxfm'
    yield assert_equal, res.interface.cmdline, realcmd
    inputs = dict(flags='-v')
    res = flirter.applyxfm(**inputs)
    realcmd ='flirt -in foo.nii -ref mni152.nii -init inmatrix.mat -v -applyxfm'
    yield assert_equal, res.interface.cmdline, realcmd


#test fnirt
def test_fnirt():
    fnirt = fsl.Fnirt()
    yield assert_equal, fnirt.cmd, 'fnirt'

    # Test inputs with variable number of values
    fnirt.inputs.sub_sampling = [8,6,4]
    yield assert_equal, fnirt.inputs.sub_sampling, [8,6,4]
    fnirtd = fnirt.run(infile='infile', reference='reference')
    realcmd = 'fnirt --in=infile --ref=reference --subsample 8 6 4'
    yield assert_equal, fnirtd.runtime.cmdline, realcmd

    fnirt2 = fsl.Fnirt(sub_sampling=[8,2])
    fnirtd2 = fnirt2.run(infile='infile', reference='reference')
    realcmd = 'fnirt --in=infile --ref=reference --subsample 8 2'
    yield assert_equal, fnirtd2.runtime.cmdline, realcmd

    # Test case where input that can be a list is just a single value
    params = [('sub_sampling', '--subsample'),
              ('max_iter', '--miter'),
              ('referencefwhm', '--reffwhm'),
              ('imgfwhm', '--infwhm'),
              ('lambdas', '--lambda'),
              ('estintensity', '--estint'),
              ('applyrefmask', '--applyrefmask'),
              ('applyimgmask', '--applyinmask')]
    for item, flag in params:
        fnirt = fsl.Fnirt(**{item : 5})
        if item == 'sub_sampling':
            cmd = 'fnirt %s %d' % (flag, 5)
        else:
            cmd = 'fnirt %s %f' % (flag, 5)
        yield assert_equal, fnirt.cmdline, cmd

    # Test error is raised when missing required args
    fnirt = fsl.Fnirt()
    yield assert_raises, AttributeError, fnirt.run
    fnirt.inputs.infile = 'foo.nii'
    yield assert_raises, AttributeError, fnirt.run
    fnirt.inputs.reference = 'mni152.nii'
    res = fnirt.run()
    yield assert_equal, type(res), fsl.InterfaceResult

    opt_map = {
        'affine':           ('--aff affine.mat', 'affine.mat'),
        'initwarp':         ('--inwarp warp.mat', 'warp.mat'),
        'initintensity':    ('--intin inten.mat', 'inten.mat'),
        'configfile':       ('--config conf.txt', 'conf.txt'),
        'referencemask':    ('--refmask ref.mat', 'ref.mat'),
        'imagemask':        ('--inmask mask.nii', 'mask.nii'),
        'fieldcoeff_file':  ('--cout coef.txt', 'coef.txt'),
        'outimage':         ('--iout out.nii', 'out.nii'),
        'fieldfile':        ('--fout fld.txt', 'fld.txt'),
        'jacobianfile':     ('--jout jaco.txt', 'jaco.txt'),
        'reffile':          ('--refout refout.nii', 'refout.nii'),
        'intensityfile':    ('--intout intout.txt', 'intout.txt'),
        'logfile':          ('--logout log.txt', 'log.txt'),
        'verbose':          ('--verbose', True),
        'flags':            ('--fake-flag', '--fake-flag')}

    for name, settings in opt_map.items():
        fnirt = fsl.Fnirt(**{name : settings[1]})
        yield assert_equal, fnirt.cmdline, ' '.join([fnirt.cmd, settings[0]])
