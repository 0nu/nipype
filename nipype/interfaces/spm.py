"""
The spm module provides basic functions for interfacing with matlab and spm to 
access spm tools.

these functions include 
    
    Realign: within-modality registration

    SliceTiming : correcting differences in image acquisition time between slices

    Coregister: between modality registration
    
    Normalize: non-linear warping to standard space

    Segment: bias correction, segmentation

"""
#from __future__ import with_statement

from nipype.interfaces.base import Bunch, CommandLine, Interface
from nipype.externals.pynifti import load
from nipype.interfaces.matlab import fltcols
import nipype.interfaces.matlab as matlab
from scipy.io import savemat
import numpy as np
import os
from nipype.utils import InTemporaryDirectory

mlab = matlab.Matlab()

class SpmInfo(object):
    @setattr_on_read
    def spm_path(self):
        try:
            InTemporaryDirectory()
            mlab.run_matlab_script("""
spm_path = spm('dir');
fid = fopen('spm_path.txt', 'wt');
fprintf(fid, '%s', spm_path);
fclose(fid);
""")
            spm_path = file('spm_path.txt', 'rt').read()
            return spm_path
        except:
            print 'Failed to return spm path'
            return None
       


spm_info = SpmInfo()


def make_job(jobtype, jobname, contents):
    return {'jobs':[{jobtype:[{jobname:contents}]}]}

def generate_job(prefix,contents):
    """ Recursive function to generate spm job specification as a string
    
    Arguments:
    - `prefix`:
    - `contents`:
    """
    jobstring = ''
    if type(contents) == type([]):
        for i,value in enumerate(contents):
            newprefix = "%s(%d)" % (prefix,i+1)
            jobstring += generate_job(newprefix,value)
        return jobstring
    if type(contents) == type({}):
        for key,value in contents.items():
            newprefix = "%s.%s" % (prefix,key)
            jobstring += generate_job(newprefix,value)
        return jobstring
    if type(contents) == type(np.empty(1)):
        #Assumes list of filenames embedded in a numpy array
        jobstring += "%s = {...\n"%(prefix)
        for item in contents:
            jobstring += '\'%s\';...\n'%(item)
        jobstring += '};\n'
        return jobstring
    if type(contents) == type(''):
        jobstring += "%s = '%s';\n" % (prefix,contents)
        return jobstring
    jobstring += "%s = %s;\n" % (prefix,str(contents))
    return jobstring

def make_mfile(jobtype, jobname, contents):
    """ generates a mfile to build job structure
    >>> import numpy as np
    >>> import nipype.interfaces.spm as spm
    >>> tmp = [{'estimate':{'files':np.array(['a.nii','b.nii']),'eoptions':{'interp':2},'roptions':{}}}]
    >>> spm.make_mfile('spatial','realign',tmp)
    """
    
    mfile = '% generated by nipype.interfaces.spm\n'
    mfile += "spm_defaults;\n\n"
    mfile += generate_job('jobs{1}.%s{1}.%s{1}' % (jobtype,jobname) ,contents[0])
    mfile += 'spm_jobman(\'run\',jobs);'
    return mfile

def make_mfile_old(jobtype, jobname, contents):
    """ generates a mfile to build job structure"""
    
    mfile = '% generated by nipype.interfaces.spm\n'
    mfile += "spm_defaults;\n\n"

    subfield = contents[0].keys()[0]
    #mfile += "jobs{1}.%s{1}.%s.data.scans = {...\n"%(jobtype,jobname)
    #for item in contents[0][subfield]['data']:
    #    mfile += '%s;...\n'%(item[0])
    #mfile += '};\n'

    for key, value in contents[0][subfield].items():
        if type(value) == type(np.empty(1)):
            mfile += "jobs{1}.%s{1}.%s{1}.%s.%s = {...\n"%(jobtype,
                                                           jobname,
                                                           subfield,
                                                           key)
            for item in contents[0][subfield][key]:
                 mfile += '\'%s\';...\n'%(item[0])
            mfile += '};\n'
                
        if type(value) == type({}):
            for skey,val in contents[0][subfield][key].items():
                mfile += 'jobs{1}.%s{1}.%s{1}.%s.%s.%s = %s;\n'%(jobtype,
                                                                 jobname,
                                                                 subfield,
                                                                 key,
                                                                 skey,
                                                                 val)
    #print mfile
    mfile += 'spm_jobman(\'run\',jobs);'
    return mfile

def run_jobdef(jobdef,jobname='',workdir='.'):
    # fix with specified path
    try:
        #InTemporaryDirectory()
        savemat('pyjobs.mat', jobdef)
        matlab_out=mlab.run_matlab_script("""
load pyjobs;
spm_jobman('run', jobs);
""",cwd=workdir)
        return matlab_out
    finally:
        print 'Failed to run jobdef'
        return None

def scans_for_fname(fname):
    img = load(fname)
    if len(img.get_shape()) == 3:
        scans = np.zeros((n_scans, 1), dtype=object)
        scans[0] = '%s,1'%(fname)
        return scans
    else:
        n_scans = img.get_shape()[3]
        scans = np.zeros((n_scans, 1), dtype=object)
        for sno in range(n_scans):
            scans[sno] = '%s,%d' % (fname, sno+1)
        return scans


def scans_for_fnames(fnames):
    n_sess = len(fnames)
    sess_scans = np.zeros((1,n_sess), dtype=object)
    for sess in range(n_sess):
        sess_scans[0,sess] = scans_for_fname(fnames[sess])
    return sess_scans


def fname_presuffix(fname, prefix='', suffix='', use_ext=True):
    pth, fname = os.path.split(fname)
    fname, ext = os.path.splitext(fname)
    if not use_ext:
        ext = ''
    return os.path.join(pth, prefix+fname+suffix+ext)


def fnames_presuffix(fnames, prefix='', suffix=''):
    f2 = []
    for fname in fnames:
        f2.append(fname_presuffix(fname, prefix, suffix))
    return f2


class Realign(CommandLine):
    
    @property
    def cmd(self):
        return 'spm_realign'
    
    def __init__(self, **inputs):
        """use spm_realign for estimating within modality
           rigid body alignment

        Parameters
        ----------
        inputs : mapping 
            key, value pairs that will update the Realign.inputs attributes
            see self.inputs_help() for a list of Realign.inputs attributes
           
        Attributes
        ----------
        inputs : Bunch
            a (dictionary-like) bunch of options that can be passed to 
            spm_realign via a job structure
        cmdline : string
            string used to call matlab/spm via CommandLine interface
        
        

        Options
        -------

        To see optional arguments
        Realign().inputs_help()


        Examples
        --------
        
        """
        
        
    def inputs_help(self):
        doc = """
            Optional Parameters
            -------------------
            (all default to None and are unset)

            infile : list
                list of filenames to realign
            write : bool
                if True updates headers and generates
                resliced files prepended with  'r'
                if False just updates header files
                (default == True, will reslice)
            quality : float
                0.1 = fastest, 1.0 = most precise
                (spm5 default = 0.9)
            fwhm : float
                full width half maximum gaussian kernel 
                used to smoth images before realigning
                (spm default = 5.0)
            separation : float
                separation in mm used to sample images
                (spm default = 4.0)
            register_to_mean: Bool
                rtm if True uses a two pass method
                realign -> calc mean -> realign all to mean
                (spm default = False)
            weight_img : file
                filename of weighting image
                if empty, no weighting 
                (spm default = None)
            wrap : list
                Check if interpolation should wrap in [x,y,z]
                (spm default [0,0,0])
            interp: float
                degree of b-spline used for interpolation
                (spm default = 2.0)
            write_which : list of len()==2
                if write is true, 
                [inputimgs, mean]
                [2,0] reslices all images, but not mean
                [2,1] reslices all images, and mean
                [1,0] reslices imgs 2:end, but not mean
                [0,1] doesnt reslice any but generates resliced mean
            write_interp: float
                degree of b-spline used for interpolation when
                writing resliced images
                (spm default = 4.0)
            write_wrap : list
                Check if interpolation should wrap in [x,y,z]
                (spm default [0,0,0])
            write_mask: bool
                if True, mask output image
                if False, do not mask
            flags : USE AT OWN RISK
                #eg:'flags':{'eoptions':{'suboption':value}}
                        
            """
        print doc

    def _populate_inputs(self):
        self.inputs = Bunch(infile=None,
                          write=True,
                          quality=None,
                          fwhm=None,
                          separation=None,
                          register_to_mean=None,
                          weight_img=None,
                          interp=None,
                          wrap=None,
                          write_which=None,
                          write_interp=None,
                          write_wrap=None,
                          write_mask=None,
                          flags=None)
        
    def _parseinputs(self):
        """validate spm realign options
        if set to None ignore
        """
        out_inputs = []
        inputs = {}
        einputs = {'eoptions':{},'roptions':{}}

        [inputs.update({k:v}) for k, v in self.inputs.iteritems() if v is not None ]
        for opt in inputs:
            if opt is 'flags':
                einputs.update(inputs[opt])
            if opt is 'infile':
                continue
            if opt is 'write':
                continue
            if opt is 'quality':
                einputs['eoptions'].update({'quality': float(inputs[opt])})
                continue
            if opt is 'fwhm':
                einputs['eoptions'].update({'fwhm': float(inputs[opt])})
                continue
            if opt is 'separation':
                einputs['eoptions'].update({'sep': float(inputs[opt])})
                continue
            if opt is 'register_to_mean':
                einputs['eoptions'].update({'rtm': 1})
                continue
            if opt is 'weight_img':
                einputs['eoptions'].update({'weight': inputs[opt]})
                continue
            if opt is 'interp':
                einputs['eoptions'].update({'interp': float(inputs[opt])})
                continue
            if opt is 'wrap':
                if not len(inputs[opt]) == 3:
                    raise ValueError('wrap must have 3 elements')
                einputs['eoptions'].update({'wrap': inputs[opt]})
                continue
            if opt is 'write_which':
                if not len(inputs[opt]) == 2:
                    raise ValueError('write_which must have 2 elements')
                einputs['roptions'].update({'which': inputs[opt]})
                continue
            if opt is 'write_interp':
                einputs['roptions'].update({'interp': inputs[opt]})
                continue
            if opt is 'write_wrap':
                if not len(inputs[opt]) == 3:
                    raise ValueError('write_wrap must have 3 elements')
                einputs['roptions'].update({'wrap': inputs[opt]})
                continue
            if opt is 'write_mask':
                einputs['roptions'].update({'mask': int(inputs[opt])})
                continue
                
            print 'option %s not supported'%(opt)
        return einputs

    def run(self, mfile=True):
        
        job = self._compile_command(mfile)

        if mfile:
            out, cmdline = mlab.run_matlab_script(job, 
                                                  script_name='pyscript_spmrealign')
        else:
            out = run_jobdef(job)
            cmdline = ''
            
        outputs = Bunch(outfiles = fnames_prefix(self.inputs.infile,'r'))
        output = Bunch(returncode=returncode,
                       stdout=out,
                       stderr=err,
                       outputs=outputs,
                       interface=self.copy())
        return output
        
        
    def _compile_command(self,mfile=True):
        """validates spm options and generates job structure
        if mfile is True uses matlab .m file
        else generates a job structure and saves in .mat
        """
        if self.inputs.write:
            jobtype = 'estwrite'
        else:
            jobtype = 'estimate'
        valid_inputs = self._parseinputs()
        if type(self.inputs.infile) == type([]):
            sess_scans = scans_for_fnames(self.inputs.infile)
        else:
            sess_scans = scans_for_fname(self.inputs.infile)

        
        # create job structure form valid options and data
        tmp = [{'%s'%(jobtype):{'data':sess_scans,
                                'eoptions':valid_inputs['eoptions'],
                                'roptions':valid_inputs['roptions']
                                }}]
        if mfile:
            return make_mfile('spatial','realign',tmp)
        else:
            return make_job('spatial','realign',tmp)

        
        
