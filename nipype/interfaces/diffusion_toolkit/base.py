# emacs: -*- mode: python; py-indent-offset: 4; indent-tabs-mode: nil -*-
# vi: set ft=python sts=4 ts=4 sw=4 et:
"""The dtk module provides basic functions for interfacing with
Diffusion Toolkit tools.

Currently these tools are supported:

    * TODO
    
Examples
--------
See the docstrings for the individual classes for 'working' examples.

"""
__docformat__ = 'restructuredtext'

import os
import re
from glob import glob

import numpy as np

from nipype.utils.filemanip import FileNotFoundError, fname_presuffix
from nipype.interfaces.base import CommandLine, traits, TraitedSpec,\
    Directory, CommandLineInputSpec
from nipype.utils.misc import isdefined

class Info(object):
    """ Handle dtk output type and version information.

    Examples
    --------

    >>> from nipype.interfaces.dtk import Info
    >>> Info.version()  # doctest: +SKIP
    >>> Info.subjectsdir()  # doctest: +SKIP
    
    """
    
    @staticmethod
    def version():
        """Check for dtk version on system

        Parameters
        ----------
        None

        Returns
        -------
        version : str
           Version number as string or None if FSL not found

        """
        clout = CommandLine(command='dti_recon').run()

        if clout.runtime.returncode is not 0:
            return None

        dtirecon = clout.runtime.stdout
        result = re.search('dti_recon (.*)\n', dtirecon)
        version = result.group(0).split()[1]
        return version
    
    

class DTKCommandInputSpec(CommandLineInputSpec):
    """nothing to do"""
    
class DTKCommand(CommandLine):
    """Base support for DTK commands.
    """
    
    input_spec = DTKCommandInputSpec
    
    """_subjects_dir = None"""

    """
    def __init__(self, **inputs):
        super(DTKCommand, self).__init__(**inputs)
        self.inputs.on_trait_change(self._subjects_dir_update, 'subjects_dir')
        if not self._subjects_dir:
            self._subjects_dir = Info.subjectsdir()
        if not isdefined(self.inputs.subjects_dir) and self._subjects_dir:
            self.inputs.subjects_dir = self._subjects_dir
        self._subjects_dir_update()

    def _subjects_dir_update(self):
        if self.inputs.subjects_dir:
            self.inputs.environ.update({'SUBJECTS_DIR':
                                            self.inputs.subjects_dir})

    @classmethod
    def set_default_subjects_dir(cls, subjects_dir):
        cls._subjects_dir = subjects_dir

    """

    def _gen_fname(self, basename, fname=None, cwd=None, suffix=None, use_ext=True):
        '''Define a generic mapping for a single outfile

        The filename is potentially autogenerated by suffixing inputs.infile

        Parameters
        ----------
        basename : string (required)
            filename to base the new filename on
        fname : string
            if not None, just use this fname
        cwd : string
            prefix paths with cwd, otherwise os.getcwd()
        suffix : string
            default suffix
        '''
        if basename == '':
            msg = 'Unable to generate filename for command %s. ' % self.cmd
            msg += 'basename is not set!'
            raise ValueError(msg)
        if cwd is None:
            cwd = os.getcwd()
        fname = fname_presuffix(basename, suffix=suffix,
                                use_ext=use_ext, newpath=cwd)
        return fname
